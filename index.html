<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 10%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<h1>CS184 Summer 2025 Final Project</h1>
			<div style="text-align: center;"><h2><i>Waterbender: A Real-Time Interactive Fluid Simulation</i></h2></div>
			<div style="text-align: center;">Names: Alexander Waldman, Mark MacDermott, Yuanbo Jiang, Seongsoo Park </div>

			<br>

			Link to webpage: <a href="https://awaldman0.github.io/waterbender_final_report/">awaldman0.github.io/waterbender_final_report/</a>
			<br />
			Link to GitHub repo: <a href="https://github.com/awaldman0/waterbender">github.com/awaldman0/waterbender</a>
			<br>
			<a href="https://docs.google.com/presentation/d/1Egt6PA-J0QTN7RdHVlVrm-zUfxWP1CrhYYB1NdwbgcY/edit?slide=id.g374755c154a_0_119#slide=id.g374755c154a_0_119">Link to slides</a>
			<br />
			<!--
	We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
	-->

			<h2>Abstract</h2>
			<p>This project explores real-time particle-based fluid simulation and rendering in 3D based in OpenGL. Starting from a barebones template project that could render a square to the screen (using GLFW for window management and GLM for math operations), we extended the square into a cube that would house our fluid simulation. From there, we developed a particle system and implemented physical interactions that approximate the behavior of a fluid when a large number of particles are on screen. Next, we transitioned from displaying particle data as distinct points to combining them into a contiguous mesh using the k-Nearest Neighbor method. To enhance the realism of our fluid, we used area weighted vertex normals from the mesh in combination with a bloom shader and multiple passes of a gaussian blur shader (all written in GLSL), finally compositing the layers together in the framebuffer. The final version of our program can be rendered in two modes; the first displays our fluid using the fully shaded mesh, while the second shows the all of the particles that underpin the simulation. The user can switch between display modes by pressing 'P'. Waterbender has a number of other ways for the user interact with the simultion, including being able to use their mouse and/or arrow keys to rotate the cube over the x and y axes while 'R' can be pressed to reset the simulation's orientation. The user can scroll up and down to add or subtract particles from the simulation, respectively. Lastly, the user can dynamically resize the container by pressing Q, W, and E to expand along each axis and A, S, and D to contract.</p>
			<p><b>If you are viewing this as a PDF, please visit the website to see animated GIFs.</b></p>
			<div style="text-align: center;">
				<img src="intro.gif" width="600px" />
			</div>
			<h2>Technical Approach</h2>
			<h3>Particle System</h3>
			<p>In our program, each particle is reprsented with a center coordinate, radius, and velocity. Each frame, we loop though every particle in the program and call the particle class's member function <code>updatePosition()</code>, which first performs a bounds check between the particle and the outer box. If the center of the particle is within one radius of one or more of the walls, we multiply the particle's velocity by a negative multiplier (-0.6 in our case) along each of the axes for which it is out of bounds. This way, collisions/bounces against the walls of the container look natural. Next, we increment the particle's velocity by the gravity vector.</p>
			<p>Note that in our implementation, there is a global rotation matrix whose values can be altered through user input via the arrow keys or the mouse. Every piece of geometry is fed through a vertex shader that multiplies vertex coordinates by our rotation matrix. Despite that, the force of gravity is always downwards from the perspective of the user regarless of the rotations being applied in the vertex shader. In order to do so, the gravity vector applied to each particle in <code>updatePosition()</code> is <b>actually</b> the original gravity vector multiplied by the inverse of the rotation matrix. This way, particle movement as a result of this vector translates to downward movement after was apply the vertex shader.</p>
			<p>After checking for boundary collisions and applying the force of gravity, the next step in updating each particle is to check for particle-particle collisions. If the center of another particle is found to be less than two radii away from the center of the current particle, there is a collison. Subsequently, we calculate the impulse during the collision for each particle add the impulse to their velocities, thereby conserving momentum, kinetic energy, and angular momentum [2]. For simplicity, the masses of every particle are equal to 1. Although this method doesn't model our fluid as accurately as a Navier-Stokes solver would, it allows us to fairly cheaply approximate fluid properties like incompressibility and constant density/pressure. Lastly, we factor in a small, arbitrary repulsive force between nearby particles. While not the most physically accurate representation of fluid dynamics, it serves the simulation by 1) helping the particles "fall apart" after the program spawns them in as a block and 2) Contributing to the bounciness/waviness of our fluid, allowing for more convincing ripples.</p>
			<div style="text-align: center;">
				<img src="particle_sys.gif" width="400px" />
				<figcaption>Particle interactions in Waterbender</figcaption>
			</div>
			<h3>Meshing and Shaders</h3>
			After solving for each particle position at a new timestep based on the physics implemented in the Particle System, we must generate a mesh of triangles to be rendered and shaded.
			The basic steps of mesh generation are listed below in order:

			<ol>
				<li> Smooth Positions: Raw particle positions from the simulation are noisy due to collisions and rapid motion. Before meshing, each stored position is updated via an exponential moving average toward the actual particle position. This attenuates high-frequency jitter and produces a temporally stable surface.</li>
				<li> k Nearest Neighbors: For each vertex candidate, distances to all others are measured and those beyond a fixed radius are discarded. From the remainder, only a limited number of the closest are retained. This constrains connectivity to local regions and limits computational cost.</li>
				<li> Triangle Formation: Triplets are formed by taking the central vertex and all unique unordered neighbor pairs that are also mutually close. Indices are canonicalized and hashed to guarantee each triangle appears only once.</li>
				<li> Compute Normals: For each triangle, the cross product of two edge vectors yields an unnormalized face normal proportional to the triangle’s area. These are summed into the normals of their constituent vertices, then normalized to unit length, producing smooth, area-weighted vertex normals.</li>
				<li> Smooth Normals: To suppress frame-to-frame shading noise from topology changes, normals are updated via an EMA blending current and previous values. A dot product test against a reference light direction enforces consistent hemisphere orientation by flipping inverted normals.</li>
				<li> Pack vertex data: The final per-vertex positions and normals are written in an interleaved format—position components followed by normal components—matching the GPU shader’s attribute layout. This avoids indexed rendering and enables direct sequential fetch by the vertex shader.</li>
				<li> Send to GPU: Bind the mesh’s VAO and its vertex buffer, then uploads the current interleaved vertex data (positions + normals) to the GPU. If the new data is larger than the buffer’s current capacity, it reallocates the buffer with glBufferData; otherwise it just overwrites existing storage with glBufferSubData. Finally, it unbinds the VAO.</li>
			</ol>
			<div style="text-align: center;">
				<img src="mesh2.gif" width="400px" />
				<figcaption>Result of kNN meshing algorithm</figcaption>
			</div>

			<h3>Problems Encountered</h3>
			<ol>
				<li><b>Magic Numbers: </b>A large source of difficulty we ran into while developing the physics in our particle system was properly choosing coefficients (ex. the force of gravity, multiplicative constants) that maintained a level of realism/plausibility in our simulation without totally breaking things. Minute changes in particular values could cause particles to clip outside of the bounding box, ignore collisions, or even disappear entirely. Lots of time went into balancing various contants used throughout our code to ensure the stability of our simulation. </li>
				<li><b>Large-scale Simulations: </b>When simulating a large number of particles (>1000), performance drops off pretty significantly. As a result, our program defaults to 512 particles, although the user can add as many as they please by scrolling their mouse wheel upwards. A major source of this slowdown is collision handling. If we had a bit more time to extend the capabilities of our simulator adding some sort of space partitioning data structure like an octree or BVH would have been beneficial.</li>
			</ol>
			<h3>Lessons Learned</h3>
			<ol>
				<li><b>An Approximate Solution Is Better Than An Incomplete One:</b> At the outset, we intended to integrate a Navier-Stokes solver as our physics model. As we developed the particle system along with particle-box intersections, it became clear implementing the model we researched would require a substantial overhaul of our existing code. Due to the accelerated timeline of the summer semester in combination with the due date of Homework 3 and our final exam, we simply did not have the time to rework our codebase to include the solver. Unfortunately, this means our simulation does not have a high degree of physical accuracy. Despite that, choosing to move away from an extremely realistic physics model allowed us to spend more time creating a complete experience for the user by giving us time to develop more ways to interact with the simulation in addition to creating more immersive shaders.</li>
				<li><b>Working with OpenGL:</b> This was our first time directly using OpenGL and it presented us with many challenges. Rendering data to the screen is a much more involved process (especially in modern OpenGL) than we initially anticipated. Learning how to work with VAOs and VBAs was definetly a confusing process and slowed our progress a bit, but we came out the other side with a firm understanding of how to use this industry-standard library. </li>

			</ol>
			<h2>Results</h2>
			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="thousand.gif" width="400px" />
							<figcaption>1000-particle simulation</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="add-sub.gif" width="400px" />
							<figcaption>Adding and removing particles from the simulation</figcaption>
						</td>
					</tr>
					<tr>
						<td style="text-align: center;">
							<img src="resize.gif" width="400px" />
							<figcaption>Demonstration of dynamic resizing</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="rapid.gif" width="400px" />
							<figcaption>Simulation under rapid change</figcaption>
						</td>
					</tr>
				</table>
			</div>
			<h2>References</h2>
			<ol>
				<li><a href="https://www.youtube.com/watch?v=rSKMYc1CQHE">Coding Adventure: Simulating Fluids</a></li>
				<li><a href="https://en.wikipedia.org/wiki/Elastic_collision">Elastic Collision</a></li>
				<li><a href="https://cs184.eecs.berkeley.edu/sp25/resources/cgl-vector-docs/">CGL Vectors Library</a></li>
				<li><a href="https://learnopengl.com/Model-Loading/Mesh">Mesh Construction</a></li>
				<li><a href="https://www.khronos.org/opengl/wiki/Tutorial2:_VAOs,_VBOs,_Vertex_and_Fragment_Shaders_(C_/_SDL)">VAO, VBO, Vertex and Fragment Shaders</a></li>
			</ol>
			<h2>Contributions</h2>
			<p><b>Mark MacDermott:</b> Implemented mesh generation and shading from particle data provided by physics simulation.</p>
			<p><b>Alexander Waldman:</b> Researched/found starter code, set up the bounding box, implemented core classes, developed much of the particle system, contributed to final writeup and slides.</p>
			<p><b>Yuanbo Jiang:</b> Implemented control features to add or remove particles, enabled mouse-based interaction that allows rapid mmodifications to the container, and researched real-time interactive fluid simulation approaches.</p>
			<p><b>Seongsoo Park:</b> Implemented some code such as particle-particle collision and bounding box sizing, and also contributed to some parts of the slides.</p>
		</div>
	</body>
</html>
