<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 10%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<h1>CS184 Summer 2025 Final Project</h1>
			<div style="text-align: center;"><h2><i>Waterbender: A Real-Time Interactive Fluid Simulation</i></h2></div>
			<div style="text-align: center;">Names: Alexander Waldman, Mark MacDermott, Yuanbo Jiang, Seongsoo Park </div>

			<br>

			Link to webpage: <a href="https://awaldman0.github.io/waterbender_final_report/">awaldman0.github.io/waterbender_final_report/</a>
			<br />
			Link to GitHub repo: <a href="https://github.com/awaldman0/waterbender">github.com/awaldman0/waterbender</a>
			<br>
			<a href="https://docs.google.com/presentation/d/1Egt6PA-J0QTN7RdHVlVrm-zUfxWP1CrhYYB1NdwbgcY/edit?slide=id.g374755c154a_0_119#slide=id.g374755c154a_0_119">Link to slides</a>
			<br />
			<!--
	We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
	-->

			<h2>Abstract</h2>
			<p>This project explores real-time particle-based fluid simulation and rendering in 3D based in OpenGL. Starting from a barebones template project that could render a square to the screen (using GLFW for window management and GLM for math operations), we extended the square into a cube that would house our fluid simulation. From there, we developed a particle system and implemented physical interactions that approximate the behavior of a fluid when a large number of particles are on screen. Next, we transitioned from displaying particle data as distinct points to combining them into a contiguous mesh using the k-Nearest Neighbor method. To enhance the realism of our fluid, we used area weighted vertex normals from the mesh in combination with a bloom shader and multiple passes of a gaussian blur shader (all written in GLSL), finally compositing the layers together in the framebuffer. The final version of our program can be rendered in two modes; the first displays our fluid using the fully shaded mesh, while the second shows the all of the particles that underpin the simulation. The user can switch between display modes by pressing 'P'. Waterbender has a number of other ways for the user interact with the simultion, including being able to use their mouse and/or arrow keys to rotate the cube over the x and y axes while 'R' can be pressed to reset the simulation's orientation. The user can scroll up and down to add or subtract particles from the simulation, respectively. Lastly, the user can dynamically resize the container by pressing Q, W, and E to expand along each axis and A, S, and D to contract.</p>
			<p><b>If you are viewing this as a PDF, please visit the website to see animated GIFs.</b></p>
			<div style="text-align: center;">
				<img src="intro.gif" width="600px" />
			</div>
			<h2>Technical Approach</h2>
			<h3>Particle System</h3>
			<p>In our program, each particle is reprsented with a center coordinate, radius, and velocity. Each frame, we loop though every particle in the program and call the particle class's member function <code>updatePosition()</code>, which first performs a bounds check between the particle and the outer box. If the center of the particle is within one radius of one or more of the walls, we multiply the particle's velocity by a negative multiplier (-0.6 in our case) along each of the axes for which it is out of bounds. This way, collisions/bounces against the walls of the container look natural. Next, we increment the particle's velocity by the gravity vector.</p>
			<p>Note that in our implementation, there is a global rotation matrix whose values can be altered through user input via the arrow keys or the mouse. Every piece of geometry is fed through a vertex shader that multiplies vertex coordinates by our rotation matrix. Despite that, the force of gravity is always downwards from the perspective of the user regarless of the rotations being applied in the vertex shader. In order to do so, the gravity vector applied to each particle in <code>updatePosition()</code> is <b>actually</b> the original gravity vector multiplied by the inverse of the rotation matrix. This way, particle movement as a result of this vector translates to downward movement after was apply the vertex shader.</p>
			<p>After checking for boundary collisions and applying the force of gravity, the next step in updating each particle is to check for particle-particle collisions. If the center of another particle is found to be less than two radii away from the center of the current particle, there is a collison. Subsequently, we calculate the impulse during the collision for each particle add the impulse to their velocities, thereby conserving momentum, kinetic energy, and angular momentum [2]. For simplicity, the masses of every particle are equal to 1. Although this method doesn't model our fluid as accurately as a Navier-Stokes solver would, it allows us to fairly cheaply approximate fluid properties like incompressibility and constant density/pressure. Lastly, we factor in a small, arbitrary repulsive force between nearby particles. While not the most physically accurate representation of fluid dynamics, it serves the simulation by 1) helping the particles "fall apart" after the program spawns them in as a block and 2) Contributing to the bounciness/waviness of our fluid, allowing for more convincing ripples.</p>
			<div style="text-align: center;">
				<img src="particle_sys.gif" width="400px" />
				<figcaption>Particle interactions in Waterbender</figcaption>
			</div>
			<h3>Meshing and Shaders</h3>
			<h3>Problems Encountered</h3>
			<ol>
				<li><b>Magic Numbers: </b>A large source of difficulty we ran into while developing the physics in our particle system was properly choosing coefficients (ex. the force of gravity, multiplicative constants) that maintained a level of realism/plausibility in our simulation without totally breaking things. Minute changes in particular values could cause particles to clip outside of the bounding box, ignore collisions, or even disappear entirely. Lots of time went into balancing various contants used throughout our code to ensure the stability of our simulation. </li>
				<li><b>Large-scale Simulations: </b>When simulating a large number of particles (>5000), performance drops off pretty significantly. As a result, our program defaults to 512 particles, although the user can add as many as they please by scrolling their mouse wheel upwards. A major source of this slowdown is collision handling. If we had a bit more time to extend the capabilities of our simulator adding some sort of space partitioning data structure like an octree or BVH would have been beneficial.</li>
			</ol>
			<h3>Lessons Learned</h3>
			<ol>
				<li><b>An Approximate Solution Is Better Than An Incomplete One:</b> At the outset, we intended to integrate a Navier-Stokes solver as our physics model. As we developed the particle system along with particle-box intersections, it became clear implementing the model we researched would require a substantial overhaul of our existing code. Due to the accelerated timeline of the summer semester in combination with the due date of Homework 3 and our final exam, we simply did not have the time to rework our codebase to include the solver. Unfortunately, this means our simulation does not have a high degree of physical accuracy. Despite that, choosing to move away from an extremely realistic physics model allowed us to spend more time creating a complete experience for the user by giving us time to develop more ways to interact with the simulation in addition to creating more immersive shaders.</li>
			</ol>
			<h2>Results</h2>
			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="thousand.gif" width="400px" />
							<figcaption>1000-particle simulation</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="add-sub.gif" width="400px" />
							<figcaption>Adding and removing particles from the simulation</figcaption>
						</td>
					</tr>
					<tr>
						<td style="text-align: center;">
							<img src="resize.gif" width="400px" />
							<figcaption>Demonstration of dynamic resizing</figcaption>
						</td>
						<td style="text-align: center;">

						</td>
					</tr>
				</table>
			</div>
			<h2>References</h2>
			<ol>
				<li><a href="https://www.youtube.com/watch?v=rSKMYc1CQHE">Coding Adventure: Simulating Fluids</a></li>
				<li><a href="https://en.wikipedia.org/wiki/Elastic_collision">Elastic Collision</a></li>
				<li><a href="https://cs184.eecs.berkeley.edu/sp25/resources/cgl-vector-docs/">CGL Vectors Library</a></li>
			</ol>
			<h2>Contributions</h2>
			<p><b>Mark MacDermott:</b> </p>
			<p><b>Alexander Waldman:</b> </p>
			<p><b>Yuanbo Jiang:</b> </p>
			<p><b>Seongsoo Park:</b> Implemented some code such as particle-particle collision and bounding box sizing, and also contributed to some parts of the slides.</p>
		</div>
	</body>
</html>
